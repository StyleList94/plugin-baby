import {
  readFileSync,
  writeFileSync,
  readdirSync,
  existsSync,
  mkdirSync,
} from 'node:fs';
import { join, dirname } from 'node:path';

/**
 * Configuration options for crush-envy.
 * @public
 */
export interface CrushEnvyOptions {
  /**
   * Output path for the generated type file (used when injectToViteEnv is false).
   * @defaultValue `'src/env.d.ts'`
   */
  output?: string;

  /**
   * Whether to inject types into existing vite-env.d.ts file.
   * When true, modifies src/vite-env.d.ts safely.
   * When false, creates a separate file at the output path.
   * @defaultValue `true`
   */
  injectToViteEnv?: boolean;

  /**
   * Whether to generate process.env types (NodeJS.ProcessEnv).
   * @defaultValue `true`
   */
  includeProcessEnv?: boolean;
}

/**
 * Parse a single .env file and extract key-value pairs.
 * @internal
 */
function parseEnvFile(filePath: string): Map<string, string> {
  const envMap = new Map<string, string>();

  if (!existsSync(filePath)) {
    return envMap;
  }

  const content = readFileSync(filePath, 'utf-8');
  const lines = content.split('\n');

  const pattern = /^([^=]+)=(.*)$/;

  for (const line of lines) {
    const trimmed = line.trim();

    // Skip empty lines and comments, process valid lines
    if (trimmed && !trimmed.startsWith('#')) {
      const match = pattern.exec(trimmed);
      if (match) {
        const key = match[1].trim();
        const value = match[2].trim();
        envMap.set(key, value);
      }
    }
  }

  return envMap;
}

/**
 * Find all .env* files in the root directory.
 * @internal
 */
function findEnvFiles(root: string): string[] {
  const files = readdirSync(root);
  return files
    .filter((file) => file.startsWith('.env'))
    .map((file) => join(root, file))
    .sort();
}

/**
 * Generate ImportMetaEnv interface block.
 * @internal
 */
function generateImportMetaEnv(keys: string[]): string {
  const sortedKeys = [...keys].sort();

  const envProperties = sortedKeys
    .map((key) => `  readonly ${key}: string;`)
    .join('\n');

  return `interface ImportMetaEnv {
${envProperties}
}`;
}

/**
 * Generate NodeJS.ProcessEnv namespace block.
 * @internal
 */
function generateProcessEnv(keys: string[]): string {
  const sortedKeys = [...keys].sort();

  const envProperties = sortedKeys
    .map((key) => `    readonly ${key}: string;`)
    .join('\n');

  return `declare namespace NodeJS {
  interface ProcessEnv {
${envProperties}
  }
}`;
}

/**
 * Generate full type declaration content for separate file mode.
 * @internal
 */
function generateFullContent(keys: string[], includeProcessEnv: boolean): string {
  let content = `// Auto-generated by vite-plugin-crush-envy
// Do not edit this file manually

${generateImportMetaEnv(keys)}
`;

  if (includeProcessEnv) {
    content += `\n${generateProcessEnv(keys)}\n`;
  }

  return content;
}

/**
 * Inject ImportMetaEnv interface into existing file content.
 * @internal
 */
function injectImportMetaEnv(existingContent: string, newInterface: string): string {
  const interfaceRegex = /interface\s+ImportMetaEnv\s*\{[\s\S]*?\}/;

  if (interfaceRegex.test(existingContent)) {
    return existingContent.replace(interfaceRegex, newInterface);
  }

  return `${existingContent.trimEnd()}\n\n${newInterface}\n`;
}

/**
 * Inject ProcessEnv namespace into existing file content.
 * @internal
 */
function injectProcessEnv(existingContent: string, newNamespace: string): string {
  const namespaceRegex = /declare\s+namespace\s+NodeJS\s*\{[\s\S]*?\n\}/;

  if (namespaceRegex.test(existingContent)) {
    return existingContent.replace(namespaceRegex, newNamespace);
  }

  return `${existingContent.trimEnd()}\n\n${newNamespace}\n`;
}

/**
 * Remove ProcessEnv namespace from existing file content.
 * @internal
 */
function removeProcessEnv(existingContent: string): string {
  const namespaceRegex = /\n*declare\s+namespace\s+NodeJS\s*\{[\s\S]*?\n\}/;
  return existingContent.replace(namespaceRegex, '');
}

/**
 * Generate TypeScript types from .env files.
 * @public
 */
export function generateEnvTypes(
  root: string,
  options: CrushEnvyOptions = {},
): void {
  const { output = 'src/env.d.ts', injectToViteEnv = true, includeProcessEnv = true } = options;

  // Find all .env* files
  const envFiles = findEnvFiles(root);

  if (envFiles.length === 0) {
    return;
  }

  // Collect all keys from all .env files
  const allKeys = new Set<string>();

  for (const envFile of envFiles) {
    const envMap = parseEnvFile(envFile);
    for (const key of envMap.keys()) {
      allKeys.add(key);
    }
  }

  if (allKeys.size === 0) {
    return;
  }

  const keys = [...allKeys];

  if (injectToViteEnv) {
    // Inject mode: modify src/vite-env.d.ts
    const viteEnvPath = join(root, 'src/vite-env.d.ts');
    const viteEnvDir = dirname(viteEnvPath);

    if (!existsSync(viteEnvDir)) {
      mkdirSync(viteEnvDir, { recursive: true });
    }

    const importMetaEnvInterface = generateImportMetaEnv(keys);

    if (existsSync(viteEnvPath)) {
      // Read existing content and inject
      let newContent = readFileSync(viteEnvPath, 'utf-8');
      newContent = injectImportMetaEnv(newContent, importMetaEnvInterface);

      if (includeProcessEnv) {
        const processEnvNamespace = generateProcessEnv(keys);
        newContent = injectProcessEnv(newContent, processEnvNamespace);
      } else {
        newContent = removeProcessEnv(newContent);
      }

      writeFileSync(viteEnvPath, newContent, 'utf-8');
    } else {
      // Create new file with reference
      let content = `/// <reference types="vite/client" />\n\n${importMetaEnvInterface}\n`;

      if (includeProcessEnv) {
        content += `\n${generateProcessEnv(keys)}\n`;
      }

      writeFileSync(viteEnvPath, content, 'utf-8');
    }
  } else {
    // Separate file mode: create new file at output path
    const outputPath = join(root, output);
    const outputDir = dirname(outputPath);

    if (!existsSync(outputDir)) {
      mkdirSync(outputDir, { recursive: true });
    }

    const content = generateFullContent(keys, includeProcessEnv);
    writeFileSync(outputPath, content, 'utf-8');
  }
}
